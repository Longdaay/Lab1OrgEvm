//Лабораторная работа № 1 - работа с двоичным представлением чисел в памяти ПК
#include <iostream>
#include <climits>
#include <vector>
#include <Windows.h>

namespace s // пространство имен s для объединения типов данных для вводимого числа
{
	static union
	{
		short digit;
		float digit_f;
	};
	static union
	{
		int dig_int[2];
		double dig_db;
	};
}

const int NotUsed = system("color 70");

int count_qual = 0; // значение, на которое необходимо изменить заполнение массива
short param_f = 12; // переменная, которая определяет выбранный тип данных
bool format = true;

void SetColor(int text, int bg) //Функция смены цвета, взятая из Интернета
{
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdOut, (WORD)((bg << 4) | text));
}

void mask_digit(const unsigned short qual, int revers_array[], int number_of_bit)
{
	bool result;
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit; number_of_bit < qual - count_qual; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::digit & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
	std::cout << '\n'; // перевод строки
}

void mask_digit_f(const unsigned short qual, int revers_array[], int number_of_bit)
{;
	bool result;
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit; number_of_bit < 33; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::dig_int[0] & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
	std::cout << '\n'; // перевод строки
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit = 33; number_of_bit < 64; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::dig_int[1] & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
}

void print_revers_array(const unsigned short qual, int revers_array[])
{
	std::cout << "Двоичное представление числа: " << '\n' << '\n';
	bool counter = 0; // значение, которое позволяет контролировать первый значащий разряд числа
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1 - count_qual; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1 - count_qual) // отделяем знак от числа единожды
		{
			std::cout << revers_array[i]; // вывод значения бита
			std::cout << " "; // пробел отделяющий знак числа
		}
		else if (revers_array[i] == 0 and counter == 0) // проверяем выводим бит является ли значащим и вместе с ним равен ли параметр ЛОЖЬ. Необходимо для того, чтобы найти значащие биты и выделить их цветом
		{
			std::cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			counter = 1; // устанавливаем в истину, как только получили первый значащий разряд
			SetColor(3, 7); // устанавливаем цвет шрифта в желтый
			std::cout << revers_array[i]; //вывод значения бита
		}
		if (i % 8 == 0) // отделяем после 8го значения пробелом для удобного восприятия числа
			std::cout << " ";
	}
	SetColor(0, 7); // возвращаем цвет шрифта в белый
}

void print_revers_array_db(const unsigned short qual, int revers_array[])
{
	std::cout << "Двоичное представление числа: " << '\n' << '\n';
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1) // отделяем знак от числа единожды
		{
			std::cout << revers_array[i]; // вывод значения бита
			std::cout << " "; // пробел отделяющий знак числа
		}
		else if (i + param_f > qual - 1) // выделяем первые биты порядка вещественного цветом и выводим. После того, как условие станет ложным - выделяем биты мантиссы другим цветом и выводим 
		{
			SetColor(5, 7);
			std::cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			SetColor(12, 7);
			std::cout << revers_array[i]; //вывод значения бита
		}
		if (i == 52)
			std::cout << " ";
	}
	SetColor(0, 7); // возвращаем цвет шрифта в белый
}

void checkdigit()
{
	while (true)
	{
		// вводим число, которое хотим представить в двоичной форме
		std::cin >> s::digit; // число целое

		if (std::cin.fail()) // ecли предыдущее извелечение оказлось неудачным,
		{
			std::cin.clear(); // то возвращаем cin в обычный режим работы
			std::cin.ignore(32767, '\n'); // и удаляем из буфера значения предыдущего ввода 
			std::cout << "Недопустимое заданное число. Введите число правильно" << '\n';
		}
		else
		{
			std::cin.ignore(32767, '\n'); // удаляем из буфера значения предыдущего ввода
			return;
		}
	}
}

void checkdigit_f()
{
	while (true)
	{
		// вводим число, которое хотим представить в двоичной форме
		if (format)
			std::cin >> s::dig_db; // число целое
		else
			std::cin >> s::digit_f;

		if (std::cin.fail()) // ecли предыдущее извелечение оказлось неудачным,
		{
			std::cin.clear(); // то возвращаем cin в обычный режим работы
			std::cin.ignore(32767, '\n'); // и удаляем из буфера значения предыдущего ввода 
			std::cout << "Недопустимое заданное число. Введите число правильно" << '\n';
		}
		else
		{
			std::cin.ignore(32767, '\n'); // удаляем из буфера значения предыдущего ввода 
			return;
		}
	}
}

int main()
{
	setlocale(0, "");

	int number_of_bit = 0; // номер бита, которым производим сдвиг
	const unsigned short qual = 64; // обозначает разрядность будущего числа
	int revers_array[qual]; // массив, который хранит слепок числа в перевернутом виде

	std::cout << "___________________ I ЧАСТЬ - _____________________" << '\n';
	std::cout << "                  Целое число long         " << '\n';
	std::cout << "Введите целое число арабскими цифрами (Пример: 10, -10, 5251, 0): " << '\n';
	checkdigit();
	// выбираем формат значения
	count_qual = 32; // устанавливаем глобальное значение для изменения диапазона массива

	mask_digit(qual, revers_array, number_of_bit); // функция создания слепка числа
	print_revers_array(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	std::cout << '\n';

	system("pause");


	count_qual = 0; // обнуляем значение, на которое необходимо изменить заполнение массива 
	std::cout << "___________________ II ЧАСТЬ - _____________________" << '\n';
	std::cout << "               Вещественное число double          " << '\n';
	std::cout << "Введите неотрицательное вещественное число арабскими цифрами (Пример: 3.14, 15.0, 5251.432, 0.0): " << '\n';

	checkdigit_f();

	mask_digit_f(qual, revers_array, number_of_bit); // функция создания слепка числа
	print_revers_array_db(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	std::cout << '\n';

	system("pause");

	return 0;
}
