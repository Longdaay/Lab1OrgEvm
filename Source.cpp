//Лабораторная работа № 1 - работа с двоичным представлением чисел в памяти ПК
#include <iostream>
#include <climits>
#include <Windows.h>

namespace s // пространство имен s для объединения типов данных для вводимого числа
{
	static union
	{
		short digit;
		float digit_f;
	};
	static union
	{
		int dig_int[2];
		double dig_db;
	};
}

const int NotUsed = system("color 70");

int count_qual = 0; // значение, на которое необходимо изменить заполнение массива
short param_f = FALSE; // переменная, которая определяет выбранный тип данных
bool format = false;

void SetColor(int text, int bg) //Функция смены цвета, взятая из Интернета
{
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdOut, (WORD)((bg << 4) | text));
}

void chooseFormat_f() // функция проверки значения в зависимости от выбранного формата
{
	using std::cout;
	using std::cin;
	char value[256]; // переменная, которая хранит выбранный формат числа
	// считываем выбранное значение
	cin >> value;
	if (strlen(value) == 1)// проверяем количество введенных символов. Если много, то просим ввести еще раз, иначе проверям выбранный формат
	{
		// устанавливаем количество значений для слепка числа в зависимости от его формата и также проверяем, входит ли значение вводимого числа в конкретный диапазон
		switch (value[0]) // проверям выбранный формат, взяв первый символ переменной value
		{
		case '1':
			count_qual = 32; // устанавливаем глобальное значение для изменения диапазона массива
			param_f = 8; // определяет выбранный тип данных float
			cout << "Ваш выбор float" << '\n';
			break;

		case '2':
			param_f = 12; // определяет выбранный тип данных double
			format = true;
			cout << "Ваш выбор double" << '\n';
			break;
		default:
			cout << "Число введено неверное. Введите номер заново" << '\n'; // если выбранный формат не соответсвует ни одному из предложенных
			chooseFormat_f();
		}
	}
	else // если введено символов больше необходимого
	{
		cout << "Необходимо ввести один символ. Попробуйте ввести заново" << '\n';
		chooseFormat_f();
	}
}

void mask_digit(const unsigned short qual, int revers_array[], int number_of_bit, bool result)
{
	using std::cout;
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit; number_of_bit < qual - count_qual; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::digit & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
	cout << '\n'; // перевод строки
}

void mask_digit_f(const unsigned short qual, int revers_array[], int number_of_bit, bool result)
{
	using std::cout;
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit; number_of_bit < 33; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::dig_int[0] & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
	cout << '\n'; // перевод строки
	// делаем слепок числа с помощью побитового сдвига и умножения в цикле
	for (number_of_bit = 33; number_of_bit < 64; number_of_bit++) // номер бита для сдвига, сравниваем номер бита с допустимым значением диапазона массива, добавляем 1 после каждой итерации
	{
		result = s::dig_int[1] & (1U << number_of_bit); // производим сдвиг числа и записываем бит в переменную
		revers_array[number_of_bit] = result; // записываем в массив полученное значение 
	}
}

void print_revers_array(const unsigned short qual, int revers_array[])
{
	using std::cout;
	cout << "Двоичное представление числа: " << '\n' << '\n';
	bool counter = 0; // значение, которое позволяет контролировать первый значащий разряд числа
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1 - count_qual; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1 - count_qual) // отделяем знак от числа единожды
		{
			cout << revers_array[i]; // вывод значения бита
			cout << " "; // пробел отделяющий знак числа
		}
		else if (revers_array[i] == 0 and counter == 0) // проверяем выводим бит является ли значащим и вместе с ним равен ли параметр ЛОЖЬ. Необходимо для того, чтобы найти значащие биты и выделить их цветом
		{
			cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			counter = 1; // устанавливаем в истину, как только получили первый значащий разряд
			SetColor(3, 7); // устанавливаем цвет шрифта в желтый
			cout << revers_array[i]; //вывод значения бита
		}
		if (i % 8 == 0) // отделяем после 8го значения пробелом для удобного восприятия числа
			cout << " ";
	}
	SetColor(0, 7); // возвращаем цвет шрифта в белый
}

void print_revers_array_f(const unsigned short qual, int revers_array[])
{
	using std::cout;
	cout << "Двоичное представление числа: " << '\n' << '\n';
	bool counter = 0; // значение, которое позволяет контролировать первый значащий разряд числа
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1 - count_qual; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1 - count_qual) // отделяем знак от числа единожды
		{
			cout << revers_array[i]; // вывод значения бита
			cout << " "; // пробел отделяющий знак числа
		}
		else if (i + param_f > qual - 1 - count_qual) // выделяем первые биты порядка вещественного цветом и выводим. После того, как условие станет ложным - выделяем биты мантиссы другим цветом и выводим 
		{
			SetColor(5, 7);
			cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			SetColor(12, 7);
			cout << revers_array[i]; //вывод значения бита
		}
		if (format)
		{
			if (i == 52)
				cout << " ";
		}
		else
			if (i == 24)
				cout << " ";
	}
	SetColor(0, 7); // возвращаем цвет шрифта в белый
}

void print_revers_array_db(const unsigned short qual, int revers_array[])
{
	using std::cout;
	cout << "Двоичное представление числа: " << '\n' << '\n';
	bool counter = 0; // значение, которое позволяет контролировать первый значащий разряд числа
	// выводим на экран слепок числа,  перевернув его
	for (int i = qual - 1; i >= 0; i = i - 1) // берем последний бит в допустимом значении диапазона массива, цикл будет проходить до последнего значения бита, снижаем на 1 после каждой итерации
	{
		if (i == qual - 1) // отделяем знак от числа единожды
		{
			cout << revers_array[i]; // вывод значения бита
			cout << " "; // пробел отделяющий знак числа
		}
		else if (i + param_f > qual - 1) // выделяем первые биты порядка вещественного цветом и выводим. После того, как условие станет ложным - выделяем биты мантиссы другим цветом и выводим 
		{
			SetColor(5, 7);
			cout << revers_array[i]; // вывод значения бита
		}
		else
		{
			SetColor(12, 7);
			cout << revers_array[i]; //вывод значения бита
		}
		if (i == 52)
			cout << " ";
	}
	SetColor(0, 7); // возвращаем цвет шрифта в белый
}

void checkdigit(bool param)
{
	using std::cout;
	using std::cin;
	while (true)
	{
		// вводим число, которое хотим представить в двоичной форме
		cin >> s::digit; // число целое

		if (cin.fail()) // ecли предыдущее извелечение оказлось неудачным,
		{
			cin.clear(); // то возвращаем cin в обычный режим работы
			cin.ignore(32767, '\n'); // и удаляем из буфера значения предыдущего ввода 
			cout << "Недопустимое заданное число. Введите число правильно" << '\n';
		}
		else
		{
			cin.ignore(32767, '\n'); // удаляем из буфера значения предыдущего ввода
			return;
		}
	}
}

void checkdigit_f()
{
	using std::cout;
	using std::cin;
	while (true)
	{
		// вводим число, которое хотим представить в двоичной форме
		if (format)
			cin >> s::dig_db; // число целое
		else
			cin >> s::digit_f;

		if (cin.fail()) // ecли предыдущее извелечение оказлось неудачным,
		{
			cin.clear(); // то возвращаем cin в обычный режим работы
			cin.ignore(32767, '\n'); // и удаляем из буфера значения предыдущего ввода 
			cout << "Недопустимое заданное число. Введите число правильно" << '\n';
		}
		else
		{
			cin.ignore(32767, '\n'); // удаляем из буфера значения предыдущего ввода 
			return;
		}
	}
}

bool checkresult() // функция для проверки числа. Необходим для удобства использования функции для выполнения задания со сменой битов в числе
{
	bool result;
	if (s::digit >= 0)
		result = FALSE;
	else
		result = TRUE;

	return result;
}

int main()
{
	setlocale(0, ""); // локализация
	using std::cout;
	using std::cin;
	int number_of_bit = 0; // номер бита, которым производим сдвиг
	bool result = checkresult(); // переменная, которая хранит значения преобразования после сдвига 
	const unsigned short qual = 64; // обозначает разрядность будущего числа
	int revers_array[qual]; // массив, который хранит слепок числа в перевернутом виде
	bool param = FALSE; // переменная, которая хранит формат числа - "0" - целое число, "1" - вещественное число

	cout << "___________________ I ЧАСТЬ - _____________________" << '\n';
	cout << "                  Целое число long         " << '\n';
	cout << "Введите целое число арабскими цифрами (Пример: 10, -10, 5251, 0): " << '\n';
	checkdigit(param); // проверка числа
	// выбираем формат значения
	count_qual = 32; // устанавливаем глобальное значение для изменения диапазона массива 
	mask_digit(qual, revers_array, number_of_bit, result); // функция создания слепка числа
	print_revers_array(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	cout << '\n'; // пустая строка

	system("pause");

	param = TRUE; // необходимо что б выполнить 2ую часть задания - чтобы произвести проверку вещественного числа
	count_qual = 0; // обнуляем значение, на которое необходимо изменить заполнение массива 
	cout << "___________________ II ЧАСТЬ - _____________________" << '\n';
	cout << "               Вещественное число           " << '\n';
	// выбираем формат значения
	cout << "Выберите формат числа:" << '\n';
	cout << "1 - float" << '\n';
	cout << "2 - double" << '\n';
	chooseFormat_f(); // функция проверки значения в зависимости от выбранного формата
	cout << "Введите неотрицательное вещественное число арабскими цифрами (Пример: 3.14, 15.0, 5251.432, 0.0): " << '\n';

	checkdigit_f(); // проверка числа

	if (format)
	{
		mask_digit_f(qual, revers_array, number_of_bit, result); // функция создания слепка числа
		print_revers_array_db(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	}
	else
	{
		mask_digit(qual, revers_array, number_of_bit, result); // функция создания слепка числа
		print_revers_array_f(qual, revers_array); // функция вывода массива полученный значений, перевернув его
	}
	//print_second_task(qual, revers_array, result, number_of_bit, param); // задание № 2
	cout << '\n'; // пустая строка

	system("pause");

	return 0;
}
